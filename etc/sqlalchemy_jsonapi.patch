--- serializer.py	2016-08-15 10:43:16.000000000 -0700
+++ serializer_new.py	2016-09-08 09:25:09.000000000 -0700
@@ -11,6 +11,10 @@
 from sqlalchemy.exc import IntegrityError
 from sqlalchemy.orm.interfaces import MANYTOONE
 from sqlalchemy.util.langhelpers import iterate_attributes
+from sqlalchemy.sql import operators
+from sqlalchemy.orm import joinedload
+from sqlalchemy.orm import RelationshipProperty
+from sqlalchemy.orm.collections import MappedCollection
 from pprint import pprint
 
 from .errors import (BadRequestError, InvalidTypeForEndpointError,
@@ -303,6 +307,21 @@
         check_permission(resource, relationship.key, permission)
         return relationship
 
+    def _apply_filter(self, collection, model, attr_path, op, value):
+
+        col = None
+
+        for attr in attr_path.split('.'):
+            col = getattr(model, attr)
+            if isinstance(col.prop, RelationshipProperty):
+                model = col.prop.mapper.class_
+                collection = collection.join(col)
+
+        if col:
+            collection = collection.filter(getattr(operators, op)(col, value))
+
+        return collection
+
     def _check_json_data(self, json_data):
         """
         Ensure that the request body is both a hash and has a data key.
@@ -374,7 +393,7 @@
             except PermissionDeniedError:
                 continue
 
-            if relationship.direction == MANYTOONE:
+            if relationship.direction == MANYTOONE or not relationship.uselist:
                 if key in local_fields:
                     to_ret['relationships'][api_key] = {
                         'links': self._lazy_relationship(api_type, instance.id,
@@ -410,6 +429,8 @@
                     to_ret['relationships'][api_key]['data'] = []
 
                 related = desc(instance)
+                if isinstance(related, MappedCollection):
+                    related = related.values()
 
                 for item in related:
                     try:
@@ -466,7 +487,7 @@
         field_args = {
             k: v
             for k, v in query.items() if k.startswith('fields[')
-        }
+            }
 
         fields = {}
 
@@ -475,6 +496,24 @@
 
         return fields
 
+    def _parse_filter(self, query):
+        """
+        Parse the querystring args for filters.
+
+        :param query: Dict of query args
+        """
+        filter_args = {
+            k: v
+            for k, v in query.items() if k.startswith('filter[')
+            }
+
+        filters = {}
+        for k, v in filter_args.items():
+            attr, op = k[7:-1].rsplit('.', 1)
+            filters[attr] = op, None if v == 'None' else v
+
+        return filters
+
     def _parse_include(self, include):
         """
         Parse the querystring args or parent includes for includes.
@@ -614,12 +653,28 @@
         model = self._fetch_model(api_key)
         include = self._parse_include(query.get('include', '').split(','))
         fields = self._parse_fields(query)
+        filter = self._parse_filter(query)
         included = {}
         sorts = query.get('sort', '').split(',')
         order_by = []
 
         collection = session.query(model)
 
+        for local in include.keys():
+            if local:
+                loader = joinedload(local)
+                for remote in include[local]:
+                    if '.' in remote:
+                        for r in remote.split('.'):
+                            loader.joinedload(r)
+                    else:
+                        loader.joinedload(remote)
+                collection = collection.options(loader)
+
+        if filter:
+            for attr_path, expr in filter.items():
+                collection = self._apply_filter(collection, model, attr_path, expr[0], expr[1])
+
         for attr in sorts:
             if attr == '':
                 break
@@ -775,7 +830,7 @@
 
         return response
 
-    def patch_relationship(self, session, json_data, api_type, obj_id,
+    def patch_relationship(self, session, query, json_data, api_type, obj_id,
                            rel_key):
         """
         Replacement of relationship values.
@@ -854,10 +909,10 @@
         except KeyError:
             raise ValidationError('Incompatible Type')
 
-        return self.get_relationship(session, {}, model.__jsonapi_type__,
+        return self.get_relationship(session, query, model.__jsonapi_type__,
                                      resource.id, rel_key)
 
-    def patch_resource(self, session, json_data, api_type, obj_id):
+    def patch_resource(self, session, query, json_data, api_type, obj_id):
         """
         Replacement of resource values.
 
@@ -905,7 +960,7 @@
                     continue
 
                 self.patch_relationship(
-                    session, json_data['data']['relationships'][api_key],
+                    session, query, json_data['data']['relationships'][api_key],
                     model.__jsonapi_type__, resource.id, api_key)
 
             data_keys = set(map((lambda x: resource.__jsonapi_map_to_py__.get(x, None)), json_data['data']['attributes'].keys()))
@@ -931,9 +986,9 @@
             session.rollback()
             raise ValidationError('Incompatible data type')
         return self.get_resource(
-            session, {}, model.__jsonapi_type__, resource.id)
+            session, query, model.__jsonapi_type__, resource.id)
 
-    def post_collection(self, session, data, api_type):
+    def post_collection(self, session, query, data, api_type):
         """
         Create a new Resource.
 
@@ -1067,7 +1122,7 @@
             raise ValidationError('Incompatible data type')
         session.refresh(resource)
         response = self.get_resource(
-            session, {}, model.__jsonapi_type__, resource.id)
+            session, query, model.__jsonapi_type__, resource.id)
         response.status_code = 201
         return response
 
